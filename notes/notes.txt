Fighter Base Pointers (how to get each character struct)

TvC keeps one live “fighter struct” per on-screen slot:

P1 active (P1C1 / point)

P1 partner (P1C2 / off-screen, tag/assist)

P2 active (P2C1)

P2 partner (P2C2)

Static manager pointers (not the structs themselves):

0x803C9FCC → P1-C1 manager

0x803C9FDC → P1-C2 manager

0x803C9FD4 → P2-C1 manager

0x803C9FE4 → P2-C2 manager

Resolution flow per slot:

Read the static manager address.

Follow one or two layers of pointers inside the manager.

The final pointer is the fighter_base for that slot (e.g., 0x9246B9C0).

Sanity checks for a good base:

[base+0x24] Max HP is sane (about 10k–60k)

[base+0x28] Cur HP in [0..Max]

[base+0xF0]/[+0xF4] look like real world X/Y floats

The HUD caches:

fighter_base[P1_active], fighter_base[P1_partner], fighter_base[P2_active], fighter_base[P2_partner]

All offsets below are relative to fighter_base unless marked “absolute.”

Fighter struct offsets (relative to fighter_base)

Identity / Health

+0x14 (u32) Character ID (12 Ryu, 14 Batsu, 18 Volnutt, etc.)

+0x24 (u32) Max HP

+0x28 (u32) Cur HP

+0x2C (u32) Red life pool / Baroque pool

+0x40 (u32) Last damage chunk taken

Position

+0xF0 (f32) World X

+0xF4 (f32) World Y

Control

+0x70 (u32) Control/legality word. Rewritten constantly. Zeroing it causes slide/odd control; not velocity storage.

Sanitized by code around 0x8004AAF4.

Attack / Action ID

+0x1E8 (u32) Attack/action/state ID

+0x1EC (u32) Sub-ID / follow-up

48 = BLOCK, 51 = PUSHBLOCK

Lookups: global(ID→label) and per-character((charID,attackID)→“Ryu 5A”, etc.)

Hot Zone A (0x050–0x090 neighborhood)

+0x052/+0x053 (u8) Startup tells

+0x056/+0x057/+0x058/+0x059 (u8) Active/hit tells

0x058/0x059 align with “hit can occur now”

+0x05B (u8) Post-impact/confirm/transition pulse

+0x062 (u8) f062 “engagement/stun context”

160 IDLE_BASE

168 ENGAGED

32 ACTIVE_MOVE

0 ATTACK_ACTIVE

40 IMPACTED

8 STUN_LOCK

+0x063 (u8) f063 “phase”

Ground: 0/32 STARTUP, 6 HIT_COMMIT, 16 BLOCK_PUSH, 17 ATKR_READY, 34 CHAIN_BUFFER, 36 HIT_RESOLVE, 37/5 RECOVERY, 168 DEF_READY, 1 NEUTRAL

Air/juggle: 64 AIR_ASCEND_ATK, 192 AIR_DESC_ATK, 193 FALLING, 70 AIR_PREHIT, 68 AIR_IMPACT, 196/198/197 KB stages, 96/224/230 AIR_CHAIN_BUF*, 194 AIR_CHAIN_END

+0x064 (u8) f064 Airborne/land sub-state (WIP)

+0x072 (u8/word) f072 “move gate” (non-zero during startup+active+recovery)

Hot Zone B (stun/assist/facing/baroque mirrors)

+0xB9F0 (u32/+neigh) Internal combo/juggle count (authoritative scaling)

+0xBA50 (block) Assist state cluster (cooldowns/lockouts)

+0xBA90 (u8) Facing/orientation flag (L/R)

+0xBAA0 (block) Assist target vector (opponent deltas)

+0xBB00 (u8) Landing recovery flag

+0xBB20 (u8) TRUE_STUN (grounded normals)

+0xBB90 / +0xBBE0 (u8) Assist readiness mirrors

+0xBBE0 == 0x00 → Assist actually ready

+0xBDF0 / +0xBAF0 (u8) Stun mirrors by slot (engine duplicates truth for subsystems)

+0xCBA8–0xCBA9 (u8) Baroque-ready flags (authoritative)

Knockback / Impact cluster (floats)

~+0xBA5x–+0xBA8x: movement scaling/dash bursts/recoil/air-drift written per frame

~+0xBBA0: impact magnitude/shove strength (spikes ~29 on heavy hit or block)

Live bone transform cluster (the “floating fist” find)

Region tested: fighter_base + 0xBA40 … +0xBA9F (96 bytes). Example absolute: 0x92477400–0x9247745F for P1C1 Ryu.

Writes of 3F800000 (1.0) and 00000000 (0.0) per 4 bytes produce:

severe stretching/anchoring of Ryu’s right arm to opponent geometry,

limb collapses/offsets that change with specific offsets.

Behavior matches a live joint transform array (per-bone 3×4 matrices, big-endian floats). Animation code rewrites it every frame; our writes override components between frames.

Most reactive span for Ryu’s right arm during sweep: roughly +0x20..+0x30 within this 0xBA40 page.
Hypothesis (provisional): that sub-range maps to the upper-arm/forearm local matrix rows.

Past ~+0x50, effects taper or move to other limbs/root, consistent with walking across rows for other joints.

Practical notes:

The cluster is volatile; for stable tests, “freeze” individual offsets or run a quick restore after each poke.

This is not hitbox storage. It manipulates the skeleton; attacks that use the affected limb gain “remote” contact due to bone displacement.

Globals / HUD / training (absolute addresses)

Training toggles (0x803F5650–0x803F5680)

0x803F5650 +0x24 (u8) Training Baroque level: 00 none, 01 10%, 02 20%, …

0x803F5650 +0x20 (u8) Attack data overlay

0x803F5670 +0x20 (u8) Input display

0x803F5680 +0x10 (u8) P1 meter behavior: 00 normal, 01 recover, 02 infinite

0x803F5680 +0x08 (u8) Infinite health toggle

0x803F5680 +0x24 (u8) Free Baroque toggle

Assist portrait vs real lockout

0x803FB7F0 +0x04 (u8) Portrait “assist unavailable” flag (can lie)

Compare to fighter_base+0xBBE0 == 0x00 (actually ready)

Combo/hype UI block (presentation)

0x803FB940..: combo popup store/trigger

0x803FB950..: counter formatting/visibility

0x803FB9E0..: hype word trigger

0x803FBA70..: Baroque popup trigger

0x803FBB80/0x803FBB90: super UI glow/superflash

Compare to fighter_base+0xB9F0 (real internal combo count)

Threat / proximity

0x80405890 / 0x804050B0 / 0x80405530: constantly updating XYZ triplets (collision candidates)

0x80405BF0: similar, reacts to hitstop

0x80478A30: defender threat block; byte 0x30 flips when you’re in real danger/throw window

Match flow / pause / director

0x805610F0: pause controller (zeroing 0x18–0x24 disables pause)

0x80561100: pause darken overlay (0x24 dims)

0x805C78B0..0x805FAB70: big match/camera/announcer director blob

Baroque / input monitor (absolute)

0x9246CB9D (u8) Baroque ready gate: 0x00 not ready, else ready (authoritative)

0x9246CB9C (u8) Neighbor context byte (often 0x03)

0x9246CC48 / 0x9246CC50: Baroque activation twitches

0x9246CC40 / 0x9246CC50 / 0x9246CC60: P1 controller blocks; I dump 0x80 bytes from 0x9246CC40 each frame for live input traces

HUD / runtime config highlights

INTERVAL = 1/30.0 (poll ~30 Hz)

MIN_HIT_DAMAGE = 10 (to log a “real” hit)

Inspector slices:

HEALTH_WIRE_OFFSETS = [0x000..0x00B, 0x02A, 0x02B]

WIRE_OFFSETS = [0x062,0x063,0x064,0x072, 0x090..0x093, 0x0F0..0x0F7]

Advantage logic

Old:

Wait until both sides’ f062 return to 160; plus_frames = defender_idle_frame − attacker_idle_frame.

New (moving toward):

Use first actionable frame:

TRUE_STUN (base+0xBB20) clear,

Landing recovery (base+0xBB00) clear,

f063 in ATKR_READY (17), DEF_READY (168), or NEUTRAL (1).

Handles jump-ins, land lag, and pushback sanely.

Absolute sweep tooling we used

Absolute fill (quick confirm):

python tvc_experiments/tvc_fill_test.py --start 0x92477400 --len 0x60 --value 0x00


Absolute sweep with revert between values (what produced the “floating fist” mapping):

python tvc_experiments/sweep_fill_abs.py --start 0x92477400 --len 0x60 --mode u32 --values 0x00000000,0x3F800000 --hold 0.25 --revert-between


(You can use --mode float --values 0.0,1.0 for the same effect.)

0x92477400..0x9247740B → Upper arm vec/weight A (forearm/bicep tip, right bias)

0x9247740C..0x92477417 → Shoulder/bicep down bias

0x92477418..0x92477423 → “Anchor” / pole vector (whole arm up-left when +1)

0x9247742C..0x92477437 → Counter-anchor (lower-right pull)

0x9247742C specifically anchors Ryu's fist to P2-C1's left leg

0x92477454..0x9247745F → Hand/elbow constraint blend; 0x54 extends, 0x58/0x5C throw whole arm up-right/up-left


0x9246CB80 + 15	(16th byte)	Current hit counter	Increments per valid hit registered. Resets when combo ends or on round start.
0x9246CB80 + 31	(32nd byte)	Airborne-hit counter	Tracks number of hits landed since the fighter entered an airborne state.
-----
9246daa0
9246dab0
9246dac0 These three addresses have "something" to do with throws, but NOPing doesn't do anything

9246da90 here it is, changing hex byte 48 to 80 causes the throw animation to play, it's influenced on the next line at  9246daa0 +  hex 22, d5 for back throw, d2 for forward throw (p1-C1 only)
---
9246dad0
9246dae0 On hit both of these flash and count down, it does the same on block, if the opponent push blocks the counter immediately stops

9246b9e0 health and baroque? + 34/36 move on hit, + 48 50 also moves on hit and moves again when using baroque
-------------
Figher blocks
------------
P1C1 → 0x9246B9C0
P1C2 → 0x9246D9C0
P2C1 → 0x924789C0
P2C2 → 0x9247A9C0


9246ba20

9246b9f0 ff ff ef 34

9246ba10 index 14, setting it to 40 causes the P1-C1 to hit the top of the stage and float down, related to this is index 10, setting it to zero kills all inputs, if index 14 is set to 40 and then 10 is set to 40, Ryu stops floating, if hit he'll suddenly get control back

9246ba10, index 11, 12, set to 0c 01 causes landing animation to play, or it did, I can't get it working again, setting it to 0e makes Ryu unable to move, I assume this means the character is airborne and Ryu cannot move until the airborne flag is removed, again this is a guess


9246baf0, index 13,14,15,16 is the vector that determines the inertia of air jumps, so if I jump, hold right, it'll move. if I jump hold left it'll move, if I jump press nothing, no reaction, this only applies to super jumps (at the moment)

9246bac0, , index 13,14,15 seems to do the same thing but has...slightly different values?

9246bb00, index 5,6,7 Y value from ground, tracks jumps. Goes to zero is a move stops momentum, then tracks again. 9,10 seems to be a flag that just says "on" or "off"

9246bb20, Tracks dash movement both forward and backward, air and ground, however 9246bb20 index 13,14,15,16 seems to only track ground dashes, possibly a jump cancel timer?

9246bb30, is a simple flag that says dash is active. 

9246bae0, seems to track inputs for dash? index 5-8  bd 30 20 c5  index 13-16 bd a9 93 0b when dash is active, ALSO there seems to be some X translation shenanigans, I changed it around and Ryu was sliding even offscreen, setting index 5 to C1 throws P1-C1 off screen I believe to the left wall? but definitely does X movement, which lines up with dashing I guess, there is setting it to Bd (which is how it tracks backdashes) slides P1C1 away from the opponent infinitely, setting it to 3D slides towards. By going up a few (like 3E or 3F) the movement gets a little aggressive, I have the perfect dummy to test this with. Megaman volnutt has a known glitch that causes this flag to fire, and I can get it to fire but it looks like it's linked with something else. For now it's just a fun little oddity. Also seems to activate on pushblock, so this seems like a general X lateral movement tracker. but not movement, just..micromovements?

-------
9246bc10
9246bc20

For index 5-8 on both lines holds

ff ff ff ff
ff ff ff ff

changed to

00 00 00 16
00 00 00 11

does absolutely nothing, it reacts on hit, but nothing
----------

9246ba20 00 04 00 00 does nothing ignore

9246b9f0 ff ff ef 34 does nothing ignore

hit box bundles start with ff ff ff fe


908aee10, index 7, default 01, light punch. Set to 02 it does the end animation of Shin Sho, 00 makes ryu raise his hand and put it down, no anim, so far as I can see, any value above 02 causes Ryu to punch and then freeze in place

908aee10, index 8, default 00, nothing strange. 01 Ryu does Med kick, 02 Heavy Punch, 03 2A, 04 2B, 05 2C, 06 6C, 07 heavy punch, 08 launcher, 09 j.A, 010 j.A (second), 

908aee20, index 2, changing this to any value between 04 and 08 causes the super background to generate with the animation

908aee20, index 8, this "seems" to mess with startup, but it also doesn't, I'm not entirely sure what this is, it's not startup though.

908aee30, index 8, default 03 is normal, 00 causes Ryu to punch towards the camera, 02 causes ryu to punch backwards, 04 makes Ryu punch away from the camera

908aee40, index 15, default 01, normal, value 02 does the round start intro pose

908aee40, index 16, does the same as 908aee10

908aee50, index 2, default 3c, setting it to 3b causes Ryu to freeze at animation end, then he just punches again, forever, only enemy can interrupt. 3A is fine though...

908aee70, index 10, default 41, changing to 42 pushes Ryu back to the edge of the screen away from the opponent then freezes.

908aee90, index 13 default 3f, determines the distance of Ryu's 5A, seems that it's exponential or very sensitive? changing it to 3E makes him punch his chest and 4a goes to the opposite side of the screen, oh that's just me forgetting hex, changing it to 40 makes him stretchy like Mr. Fantastic but not agressively so

908aeea0, index 1, does the same thing as 908aee90 but for the Z value (foreground to background) instead of on the 2D plane

908aeea0, index 5, determines the squash of the animation, Ryu's arm can be a stick or a thick tree trunk when set to 00 or 40

908aef20, index 1, default 00, absolutely nothing interesting, change it to 01/04, enemy has zero health no red life on hit, change it to 02/05, enemy has no health but a full red bar on hit

908aef60, index 0, default 04, changing it to 00 removes the hitbox, but freezes on animation end

908aef60, index 15, default 02, changing to 00 causes the super background to appear during animation

908aef60, index 16, default 58, when set to 0, Ryu punches, then freezes, BUT if combined with index 15 above and both are set to zero, Ryu will lose all health, taunt twice, and then meter will slowly drop to zero

908af060, index 2, removes hitbox and freezes Ryu

908af0d0, entire line, if FF'd entire arm seems to derender on animation but is fine in neutral, hitbox is fine

908aefb0, index 13, default 41, changing it to 60 causes the hitbox to be "attached" to the enemy? I dunno, I just know I can hit him from any where on the screen, oh it seems to just be expontential, at 41 the range is doubled, 42 double that, etc. etc., setting it to FF hits anywhere on the screen but the hitspark generates at the bottom of the enemy

908af010, index 10, default 33, when changed to 00 Ryu can punch and gets frozen, BUT, if Ryu is in an attackable range, he can still punch, once out of range, Ryu is frozen, if hit by opponent Ryu is free to move, but again, if japbbing outside of range, Ryu freezes.

908af040, Index 2, hit reaction animation, default 17. My notes seems to differ from James? 01 causes spiral knockdown, 04 hard knockdown, 05 hard knockdown, 08 throw knockdown?, 10/11/12/15/16/18 spiral knockdown with massive hitstun at the front, 13/14 overhead hit,

908af050, index 2, default 15, hitstun...but not really 10 causes a lot of hitstun, 16 causes stagger knockdown

908aef40, index 16, default 40, changes hitspark, 01 makes a big ole hitspark, also any variation of X1 like 11, 21, 31, etc. X0 normal hitsparks, anything else removes it


908aef30,index 8, default 44, 43 produces no hitstun (not the hitstun value itself, just no anim), 41/42 overhead, 40 is interesting, it "looks" like a guard break animation, but it's the same animation used for Viewtiful joe Slow and Zoom or Blade's omnidirectional stagger anim

---

Ryu 5A Hitbox Structure @ 0x908AEFB0

Full 0x50-byte region

908AEFB0: 00 00 00 3F  00 00 00 00  00 00 00 3F  41 A0 00 00
908AEFC0: 35 0D 20 3F  00 00 00 0A  00 00 00 3F  00 00 00 00
908AEFD0: 00 00 00 3F  00 00 00 00  00 00 00 3F  41 20 00 00
908AEFE0: 00 00 00 3F  00 00 00 0A  00 00 00 3F  00 00 00 00


---

Confirmed / Observed Behavior

Address	Default	Float Value	Effect / Behavior

0x908AEFBC	41 A0 00 00	20.0	Expands hitbox size/range for first hitbox. Increasing this → huge global hitbox.
0x908AEFDC	41 20 00 00	10.0	Second hitbox’s radius. Increasing this affects secondary contact point; sparks drift downward as opponent moves away.
0x908AEFB8	00 00 00 3F	0.5	Changing to 40 20 00 00 (2.5) → crash. Likely struct padding, pointer, or flag bitfield, not a float.
0x908AEFD8	00 00 00 3F	0.5	Changing to 40 20 00 00 → Ryu freezes post-attack if opponent out of range. Probably an active frame duration or animation gate.
0x908AEFC8	00 00 00 0A	(int 10)	Changing to 00 00 00 14 → Ryu freezes after punch. Likely sub-hitbox count / duration counter.
0x908AEFE8	00 00 00 0A	(int 10)	(Not yet tested; predicted same effect as 0xC8.)
0x908AEF7C	(not in region, earlier)	–	“Global” hitbox range — setting to FF previously expanded all hits. Related global flag or header byte.



---

Behavior Summary

Two sequential hitboxes inside one move block (35 0D 20 3F marker denotes the start of each).

Each hitbox appears to end with a float controlling radius/range (20.0 / 10.0 defaults).

Increasing these floats enlarges the hit area proportionally.

The game accepts large positive floats but crashes or softlocks if internal padding/pointer fields are replaced with valid float patterns.

Spark offset/direction correlates with secondary hitbox range; when both are huge, engine computes mid-point → sparks shift vertically.



---

Working Theory (Field Labels)

Offset (from 0x908AEFB0)	Tentative Label	Type	Notes

+0x00	unknown_A	float	constant 0.5
+0x04	unknown_B	float	always 0.0
+0x08	unknown_C	float	constant 0.5
+0x0C	radius_1	float	Primary hitbox radius
+0x10	marker	bytes	35 0D 20 3F → hitbox delimiter
+0x14	subid_or_flags	int	“10” = 0xA; freezing if changed
+0x18	unknown_F	float	0.5f constant
+0x1C	pad	bytes	zeroed
+0x20	unknown_G	float	0.5f
+0x24	unknown_H	float	0.0
+0x28	unknown_I	float	0.5f
+0x2C	radius_2	float	Secondary hitbox radius
+0x30	unknown_J	float	0.5f
+0x34	subid2	int	“10” = 0xA; not tested yet
…	…	…	continues



---

Stable working pokes

:: reset to defaults
python tvc_sigtool.py poke --addr 0x908AEFBC --bytes "41 A0 00 00"
python tvc_sigtool.py poke --addr 0x908AEFDC --bytes "41 20 00 00"

:: enlarge first hitbox
python tvc_sigtool.py poke --addr 0x908AEFBC --bytes "43 20 00 00"

:: enlarge both
python tvc_sigtool.py poke --addr 0x908AEFBC --bytes "43 20 00 00"
python tvc_sigtool.py poke --addr 0x908AEFDC --bytes "43 20 00 00"


---

Hitbox instances we verified

Ryu 5A live block (training):

marker 1: 0x908AEF78 (35 0D 20 3F)

primary radius: 0x908AEFBC

default: 41 A0 00 00 (20.0)

enlarged test: 43 20 00 00

secondary radius: 0x908AEFDC

default: 41 20 00 00 (10.0)

enlarged test: 43 20 00 00

second marker in same move: 0x908AEFC0

second-marker radius: 0x908AF004 (= 0x908AEFC0 + 0x44)

Ryu 5B live block:

marker: 0x908AF3F0

primary radius: 0x908AF434 (= marker + 0x44)

default: 41 C8 00 00 (25.0)

enlarged: 43 20 00 00

second marker (same block): 0x908AF43C

second radius: 0x908AF480 (= 0x908AF43C + 0x44)

Ryu 5C live block:

marker: 0x908AF804

primary radius: 0x908AF848 (= marker + 0x44)

default: 41 A0 00 00 (20.0)

enlarged: 43 20 00 00

second marker: 0x908AF84C

second radius: 0x908AF890 (= 0x908AF84C + 0x44)

Rule confirmed: for this match/state, every hitbox that starts with 35 0D 20 3F has its active radius at marker+0x44.

Fighter base pointers (slots)

0x803C9FCC → P1-C1 manager

0x803C9FDC → P1-C2 manager

0x803C9FD4 → P2-C1 manager

0x803C9FE4 → P2-C2 manager

Resolution flow:

read manager at the static address

follow 1–2 pointers → fighter_base (example: 0x9246B9C0)

sanity:

[base+0x24] max HP 10k–60k

[base+0x28] current HP

[base+0xF0]/[base+0xF4] world X/Y floats

Known fighter bases from your notes:

P1C1 → 0x9246B9C0

P1C2 → 0x9246D9C0

P2C1 → 0x924789C0

P2C2 → 0x9247A9C0

Fighter struct key offsets (relative to fighter_base)

+0x14 u32 character ID

+0x24 u32 max HP

+0x28 u32 cur HP

+0x2C u32 red life / baroque pool

+0x40 u32 last damage chunk

+0x70 u32 control/legality word (constantly rewritten)

+0xF0 f32 world X

+0xF4 f32 world Y

+0x1E8 u32 attack/action/state ID

+0x1EC u32 sub-ID/follow-up

“Hot zone” bytes you mapped (relative to fighter_base):

+0x052–0x05B: startup/active/hit tells

+0x062: “engagement/stun context”

160 IDLE_BASE

168 ENGAGED

32 ACTIVE_MOVE

0 ATTACK_ACTIVE

40 IMPACTED

8 STUN_LOCK

+0x063: phase

0/32 startup

6 hit commit

16 block push

17 ATKR_READY

168 DEF_READY

1 neutral

+0x072: move gate

Absolute/runtime addresses you called out

Training toggles: 0x803F5650–0x803F5680

Pause/match director: ~0x805610F0+

Baroque/input monitor (P1): 0x9246CB80+ (hit counter etc.)

Throw-related cluster you probed: 0x9246DA90–0x9246DAE0 area

Animation/move-control cluster you poked (908AEE10+ etc.)
You mapped that 0x908AEE10/0x908AEE20/... region as the current move/animation driver:

0x908AEE10 index 7/8 picks the normal

0x908AEE30 index 8 changes facing/punch direction

0x908AEF60 index 0/15/16 affects hitbox presence and weird super BG

0x908AEFB0 index 13 (the one you cranked) makes hitbox “attach” everywhere

Those stay in the notes as “animation/state driver, not the hitbox itself.”

Stable working pokes (summary)

reset:

python tvc_sigtool.py poke --addr 0x908AEFBC --bytes "41 A0 00 00"

python tvc_sigtool.py poke --addr 0x908AEFDC --bytes "41 20 00 00"

enlarge 5A:

python tvc_sigtool.py poke --addr 0x908AEFBC --bytes "43 20 00 00"

python tvc_sigtool.py poke --addr 0x908AEFDC --bytes "43 20 00 00"

enlarge 5B:

python tvc_sigtool.py poke --addr 0x908AF434 --bytes "43 20 00 00"

enlarge 5C:

python tvc_sigtool.py poke --addr 0x908AF848 --bytes "43 20 00 00"

Move	Marker Addr	Radius Addr (+0x44)	Confirmed?	Notes
5A	0x908AEF78	0x908AEFBC	✓	baseline small jab
5B	0x908AF3F0	0x908AF434	✓	medium punch
5C	0x908AF804	0x908AF848	✓	large hitbox, strong punch
(extra 5C?)	0x908AF894	0x908AF8D8	✓	same animation as 5C
2A	0x908AFD2C	0x908AFD70	✓	crouch light
2B	0x908AFCE4	0x908AFD28	✓	crouch medium
2C	0x908B0804	0x908B0848	✓	crouch heavy
(extra 2C?)	0x908B084C	0x908B0890	?	maybe multi-hit / lingering frame
3C	—	—	pending	not yet found in this block; may appear after 0x908B0Fxx range
6C	0x908B0FE8	0x908B102C	✓	standing launcher
(extra 6C?)	0x908B1030	0x908B1074	?	likely secondary 6C hitbox or whiff zone

# Ground Normals
python tvc_sigtool.py poke --addr 0x908AEFBC --bytes "43 20 00 00"   # 5A
python tvc_sigtool.py poke --addr 0x908AF434 --bytes "43 20 00 00"   # 5B
python tvc_sigtool.py poke --addr 0x908AF848 --bytes "43 20 00 00"   # 5C (no response)
python tvc_sigtool.py poke --addr 0x908AFD70 --bytes "43 20 00 00"   # 2A
python tvc_sigtool.py poke --addr 0x908AFD28 --bytes "43 20 00 00"   # 2B (no response)
python tvc_sigtool.py poke --addr 0x908B0848 --bytes "43 20 00 00"   # 2C
python tvc_sigtool.py poke --addr 0x908B159C --bytes "43 20 00 00"   # 3C
python tvc_sigtool.py poke --addr 0x908B102C --bytes "43 20 00 00"   # 6C

# Air Normals (inactive, revisit in jump state)
python tvc_sigtool.py poke --addr 0x908B51C8 --bytes "43 20 00 00"   # j.A
python tvc_sigtool.py poke --addr 0x908B5210 --bytes "43 20 00 00"   # j.B
python tvc_sigtool.py poke --addr 0x908B5258 --bytes "43 20 00 00"   # j.C


2A / 2B share the same hitbox region.
0x908AFCE0–0x908AFD7F = unified crouching jab/mid cluster.
Both read from the same iterator; modifying 0x908AFD24 (radius) corrupts 2A’s pointer and freezes.
Treat 0x908AFD70 as the safe radius edit for both moves.

python tvc_sigtool.py poke --addr 0x908AEFBC --bytes "43 FF 00 00"   
# 5A
python tvc_sigtool.py poke --addr 0x908AF434 --bytes "43 FF 00 00"   
# 5B
python tvc_sigtool.py poke --addr 0x908AF848 --bytes "43 FF 00 00"   
# 5C

python tvc_sigtool.py poke --addr 0x908AFD28 --bytes "43 FF 00 00"   
# 2A
python tvc_sigtool.py poke --addr 0x908B02F8 --bytes "43 FF 00 00"   
# 2B
python tvc_sigtool.py poke --addr 0x908B0848 --bytes "43 FF 00 00"   
# 2C
python tvc_sigtool.py poke --addr 0x908B159C --bytes "43 FF 00 00"   
# 3C


python tvc_sigtool.py poke --addr 0x908B19F4 --bytes "43 FF 00 00"   
# j.A
python tvc_sigtool.py poke --addr 0x908B1F54 --bytes "43 FF 00 00"   
# j.B
python tvc_sigtool.py poke --addr 0x908B21C8 --bytes "43 FF 00 00"   
# j.B (second hit)
python tvc_sigtool.py poke --addr 0x908B249C --bytes "43 FF 00 00"   
# j.C

python tvc_sigtool.py poke --addr 0x908B2994 --bytes "43 FF 00 00"   
# 6B hit 1
python tvc_sigtool.py poke --addr 0x908B2C2C --bytes "43 FF 00 00"   
# 6B hit 2
python tvc_sigtool.py poke --addr 0x908B102C --bytes "43 FF 00 00"   
# 6C

python tvc_sigtool.py poke --addr 0x908B49C4 --bytes "43 FF 00 00"   
# Tatsu L
python tvc_sigtool.py poke --addr 0x908B4E7C --bytes "43 FF 00 00"   
# Tatsu M (First Hit)
python tvc_sigtool.py poke --addr 0x908b5198 --bytes "43 FF 00 00"   
# Tatsu M (second and third hit)
python tvc_sigtool.py poke --addr 0x908B5994 --bytes "43 FF 00 00"   
# Tatsu H (Last Three Hits)
python tvc_sigtool.py poke --addr 0x908b5670 --bytes "43 FF 00 00"   
# Tatsu H (First Hit)
python tvc_sigtool.py poke --addr 0x908b90AD --bytes "43 FF 00 00"   
# Tatsu L (Air)
python tvc_sigtool.py poke --addr 0x908b933C --bytes "43 FF 00 00"   
# Tatsu L (Air, second hit)
python tvc_sigtool.py poke --addr 0x908b9730 --bytes "43 FF 00 00"   
# Tatsu M (Air, first hit)
python tvc_sigtool.py poke --addr 0x908b99d0 --bytes "43 FF 00 00"   
# Tatsu M (Air, second third hit)
python tvc_sigtool.py poke --addr 0x908b9d88 --bytes "43 FF 00 00"     
# Tatsu H (Air, first)
python tvc_sigtool.py poke --addr 0x908ba0b8 --bytes "43 FF 00 00"     
# Tatsu H (Air, rest of the hits)

python tvc_sigtool.py poke --addr 0x908b5e48 --bytes "43 FF 00 00" 
# Shoryu L
python tvc_sigtool.py poke --addr 0x908b662C --bytes "43 FF 00 00" 
# Shoryu M (second hit)
python tvc_sigtool.py poke --addr 0x908b6814 --bytes "43 FF 00 00" 
# Shoryu M (first hit)
python tvc_sigtool.py poke --addr 0x908b6ef4 --bytes "43 FF 00 00" 
# Shoryu H (first hit)
python tvc_sigtool.py poke --addr 0x908b7094 --bytes "43 FF 00 00" 
# Shoryu H (second hit)

python tvc_sigtool.py poke --addr 0x908b76a4 --bytes "43 FF 00 00" 
# Donkey L
python tvc_sigtool.py poke --addr 0x908b7c18 --bytes "43 FF 00 00" 
# Donkey M
python tvc_sigtool.py poke --addr 0x908b8194 --bytes "43 FF 00 00" 
# Donkey H

Hado is around 908b8810, looking
