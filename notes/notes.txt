Fighter Base Pointers (how to get each character struct)

TvC keeps one live “fighter struct” per on-screen slot:

P1 active (P1C1 / point)

P1 partner (P1C2 / off-screen, tag/assist)

P2 active (P2C1)

P2 partner (P2C2)

Static manager pointers (not the structs themselves):

0x803C9FCC → P1-C1 manager

0x803C9FDC → P1-C2 manager

0x803C9FD4 → P2-C1 manager

0x803C9FE4 → P2-C2 manager

Resolution flow per slot:

Read the static manager address.

Follow one or two layers of pointers inside the manager.

The final pointer is the fighter_base for that slot (e.g., 0x9246B9C0).

Sanity checks for a good base:

[base+0x24] Max HP is sane (about 10k–60k)

[base+0x28] Cur HP in [0..Max]

[base+0xF0]/[+0xF4] look like real world X/Y floats

The HUD caches:

fighter_base[P1_active], fighter_base[P1_partner], fighter_base[P2_active], fighter_base[P2_partner]

All offsets below are relative to fighter_base unless marked “absolute.”

Fighter struct offsets (relative to fighter_base)

Identity / Health

+0x14 (u32) Character ID (12 Ryu, 14 Batsu, 18 Volnutt, etc.)

+0x24 (u32) Max HP

+0x28 (u32) Cur HP

+0x2C (u32) Red life pool / Baroque pool

+0x40 (u32) Last damage chunk taken

Position

+0xF0 (f32) World X

+0xF4 (f32) World Y

Control

+0x70 (u32) Control/legality word. Rewritten constantly. Zeroing it causes slide/odd control; not velocity storage.

Sanitized by code around 0x8004AAF4.

Attack / Action ID

+0x1E8 (u32) Attack/action/state ID

+0x1EC (u32) Sub-ID / follow-up

48 = BLOCK, 51 = PUSHBLOCK

Lookups: global(ID→label) and per-character((charID,attackID)→“Ryu 5A”, etc.)

Hot Zone A (0x050–0x090 neighborhood)

+0x052/+0x053 (u8) Startup tells

+0x056/+0x057/+0x058/+0x059 (u8) Active/hit tells

0x058/0x059 align with “hit can occur now”

+0x05B (u8) Post-impact/confirm/transition pulse

+0x062 (u8) f062 “engagement/stun context”

160 IDLE_BASE

168 ENGAGED

32 ACTIVE_MOVE

0 ATTACK_ACTIVE

40 IMPACTED

8 STUN_LOCK

+0x063 (u8) f063 “phase”

Ground: 0/32 STARTUP, 6 HIT_COMMIT, 16 BLOCK_PUSH, 17 ATKR_READY, 34 CHAIN_BUFFER, 36 HIT_RESOLVE, 37/5 RECOVERY, 168 DEF_READY, 1 NEUTRAL

Air/juggle: 64 AIR_ASCEND_ATK, 192 AIR_DESC_ATK, 193 FALLING, 70 AIR_PREHIT, 68 AIR_IMPACT, 196/198/197 KB stages, 96/224/230 AIR_CHAIN_BUF*, 194 AIR_CHAIN_END

+0x064 (u8) f064 Airborne/land sub-state (WIP)

+0x072 (u8/word) f072 “move gate” (non-zero during startup+active+recovery)

Hot Zone B (stun/assist/facing/baroque mirrors)

+0xB9F0 (u32/+neigh) Internal combo/juggle count (authoritative scaling)

+0xBA50 (block) Assist state cluster (cooldowns/lockouts)

+0xBA90 (u8) Facing/orientation flag (L/R)

+0xBAA0 (block) Assist target vector (opponent deltas)

+0xBB00 (u8) Landing recovery flag

+0xBB20 (u8) TRUE_STUN (grounded normals)

+0xBB90 / +0xBBE0 (u8) Assist readiness mirrors

+0xBBE0 == 0x00 → Assist actually ready

+0xBDF0 / +0xBAF0 (u8) Stun mirrors by slot (engine duplicates truth for subsystems)

+0xCBA8–0xCBA9 (u8) Baroque-ready flags (authoritative)

Knockback / Impact cluster (floats)

~+0xBA5x–+0xBA8x: movement scaling/dash bursts/recoil/air-drift written per frame

~+0xBBA0: impact magnitude/shove strength (spikes ~29 on heavy hit or block)

Live bone transform cluster (the “floating fist” find)

Region tested: fighter_base + 0xBA40 … +0xBA9F (96 bytes). Example absolute: 0x92477400–0x9247745F for P1C1 Ryu.

Writes of 3F800000 (1.0) and 00000000 (0.0) per 4 bytes produce:

severe stretching/anchoring of Ryu’s right arm to opponent geometry,

limb collapses/offsets that change with specific offsets.

Behavior matches a live joint transform array (per-bone 3×4 matrices, big-endian floats). Animation code rewrites it every frame; our writes override components between frames.

Most reactive span for Ryu’s right arm during sweep: roughly +0x20..+0x30 within this 0xBA40 page.
Hypothesis (provisional): that sub-range maps to the upper-arm/forearm local matrix rows.

Past ~+0x50, effects taper or move to other limbs/root, consistent with walking across rows for other joints.

Practical notes:

The cluster is volatile; for stable tests, “freeze” individual offsets or run a quick restore after each poke.

This is not hitbox storage. It manipulates the skeleton; attacks that use the affected limb gain “remote” contact due to bone displacement.

Globals / HUD / training (absolute addresses)

Training toggles (0x803F5650–0x803F5680)

0x803F5650 +0x24 (u8) Training Baroque level: 00 none, 01 10%, 02 20%, …

0x803F5650 +0x20 (u8) Attack data overlay

0x803F5670 +0x20 (u8) Input display

0x803F5680 +0x10 (u8) P1 meter behavior: 00 normal, 01 recover, 02 infinite

0x803F5680 +0x08 (u8) Infinite health toggle

0x803F5680 +0x24 (u8) Free Baroque toggle

Assist portrait vs real lockout

0x803FB7F0 +0x04 (u8) Portrait “assist unavailable” flag (can lie)

Compare to fighter_base+0xBBE0 == 0x00 (actually ready)

Combo/hype UI block (presentation)

0x803FB940..: combo popup store/trigger

0x803FB950..: counter formatting/visibility

0x803FB9E0..: hype word trigger

0x803FBA70..: Baroque popup trigger

0x803FBB80/0x803FBB90: super UI glow/superflash

Compare to fighter_base+0xB9F0 (real internal combo count)

Threat / proximity

0x80405890 / 0x804050B0 / 0x80405530: constantly updating XYZ triplets (collision candidates)

0x80405BF0: similar, reacts to hitstop

0x80478A30: defender threat block; byte 0x30 flips when you’re in real danger/throw window

Match flow / pause / director

0x805610F0: pause controller (zeroing 0x18–0x24 disables pause)

0x80561100: pause darken overlay (0x24 dims)

0x805C78B0..0x805FAB70: big match/camera/announcer director blob

Baroque / input monitor (absolute)

0x9246CB9D (u8) Baroque ready gate: 0x00 not ready, else ready (authoritative)

0x9246CB9C (u8) Neighbor context byte (often 0x03)

0x9246CC48 / 0x9246CC50: Baroque activation twitches

0x9246CC40 / 0x9246CC50 / 0x9246CC60: P1 controller blocks; I dump 0x80 bytes from 0x9246CC40 each frame for live input traces

HUD / runtime config highlights

INTERVAL = 1/30.0 (poll ~30 Hz)

MIN_HIT_DAMAGE = 10 (to log a “real” hit)

Inspector slices:

HEALTH_WIRE_OFFSETS = [0x000..0x00B, 0x02A, 0x02B]

WIRE_OFFSETS = [0x062,0x063,0x064,0x072, 0x090..0x093, 0x0F0..0x0F7]

Advantage logic

Old:

Wait until both sides’ f062 return to 160; plus_frames = defender_idle_frame − attacker_idle_frame.

New (moving toward):

Use first actionable frame:

TRUE_STUN (base+0xBB20) clear,

Landing recovery (base+0xBB00) clear,

f063 in ATKR_READY (17), DEF_READY (168), or NEUTRAL (1).

Handles jump-ins, land lag, and pushback sanely.

Absolute sweep tooling we used

Absolute fill (quick confirm):

python tvc_experiments/tvc_fill_test.py --start 0x92477400 --len 0x60 --value 0x00


Absolute sweep with revert between values (what produced the “floating fist” mapping):

python tvc_experiments/sweep_fill_abs.py --start 0x92477400 --len 0x60 --mode u32 --values 0x00000000,0x3F800000 --hold 0.25 --revert-between


(You can use --mode float --values 0.0,1.0 for the same effect.)

0x92477400..0x9247740B → Upper arm vec/weight A (forearm/bicep tip, right bias)

0x9247740C..0x92477417 → Shoulder/bicep down bias

0x92477418..0x92477423 → “Anchor” / pole vector (whole arm up-left when +1)

0x9247742C..0x92477437 → Counter-anchor (lower-right pull)

0x92477454..0x9247745F → Hand/elbow constraint blend; 0x54 extends, 0x58/0x5C throw whole arm up-right/up-left