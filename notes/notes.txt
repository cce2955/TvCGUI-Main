Environment / Tooling

I’m currently reverse-engineering TvC using a combination of emulator-level hooks, memory polling, and my own live HUD.

Tools in use:

Dolphin 5.0 Debug (x64)

Using breakpoints, watchpoints, register view, stepping through PPC calls, and live memory editing.

I also NOP out instructions to confirm responsibilities (movement freeze, knockback cancel, etc.).

dolphin-memory-engine (Python)

External process reader that polls Dolphin’s RAM in real time.

I use it to resolve per-character base addresses every frame, follow pointers, read interesting bytes/words/floats, and dump per-frame state.

My custom Python HUD / GUI (pygame)

Real-time overlay that shows per-character HP, meter, X/Y world position, control state, current move ID (and a label), stun flags, assist state, etc.

It also logs events (every real hit I detect) and exports collisions.csv with attacker/victim, move ID, distance at impact, etc.

I’ve added a first-pass frame advantage tracker that tries to say “+2f on block,” etc.

I’m in the process of extending the HUD to show things the vanilla game lies about, like assist readiness.

In-memory trackers:

HitTracker: figures out attacker/victim on hit from the actual health change and proximity instead of relying on effects.

AdvantageTracker: watches recovery / “I can act now” flags for both players and estimates frame advantage on hit or block.

(Experimental) Dolphin Lua:

I’ve started playing with this for auto-breakpointing and deeper correlation, but it’s not the main pipeline yet.

Spreadsheet/CSV flow:

I still support exporting session data to CSV for offline analysis, but honestly I’m way less Excel-first now that I’ve got a stable live HUD.

Fighter Struct Basics (Per-Character Live State)

Each character in TvC (P1 active, P1 partner, P2 active, P2 partner) has a live, constantly-updated “fighter struct.” This is basically the engine’s truth for that character that gets rewritten every frame. I’ll call this “the fighter struct.”

Example observed base: around 0x9246B9C0 for a character. The stride between character slots is on the order of a few hundred bytes (~0x300–0x400). All of this lives in RAM and gets hammered constantly.

The game resolves which struct belongs to which slot using pointers hanging off static addresses in the US build:

P1 active (P1-C1): 0x803C9FCC

P1 partner (P1-C2): 0x803C9FDC

P2 active (P2-C1): 0x803C9FD4

P2 partner (P2-C2): 0x803C9FE4

Those aren’t the structs themselves; those point to slot managers, and I walk a couple layers (pointers of pointers) to land on the actual fighter struct. I verify I’ve got a real fighter struct by sanity-checking HP layout (see below). If all else fails mid-match, I can re-lock onto a character by looking for “sane max HP / current HP” and position floats, even if the pointer chain flickers.

Core offsets (relative to the fighter struct base r3 in PPC terms):

Health / Identity:

+0x24 (word): Max HP

+0x28 (word): Current HP

+0x2C (word): Red life / recoverable health / baroque pool

+0x14 (word): Character ID (Ryu = 12, Batsu = 14, Volnutt = 18, etc.)

+0x40 (word): “last damage chunk,” updates whenever you get hit

I use these to confirm I’m tracking the right struct for that slot.

Position:

+0xF0 / +0xF4 (floats): world X / world Y (and nearby Z in some cases)

I probe for which float consistently behaves like “vertical position” instead of camera pan or stage scroll.

I draw those as X:###.## Y:###.## in the HUD.

Control word:

+0x70 (word): ctrl

This is a per-frame control/state mask. The game rewrites and sanitizes it constantly.

If I manually force this to zero mid-frame (stw r0,0x70(r3) in Dolphin), Ryu basically loses grounded stability and slides forever, so +0x70 is very tied to allowed movement/impulse.

But it’s not “velocity storage,” because the engine just replaces it next frame anyway.

There’s a routine at 0x8004AAF4 that does something like:

read [r3+0x70]

rlwinm stuff

write a sanitized version back with stw r4,0x70(r3)

This looks like the master “clamp/control gate” each frame.

Attack / State ID:

+0x1E8 (word): Attack / action ID

+0x1EC (word): Sub-ID / followup

The game treats even blocking as a “move,” so blocking has an attack ID too. Examples I’ve confirmed:

48 = BLOCK

51 = PUSHBLOCK

I maintain two lookup maps:

global: attack ID → generic label (BLOCK, PUSHBLOCK, etc.)

per-character: (charID, attackID) → move name (“Ryu 5A”, “Batsu j.C”, etc.)

The HUD will preferentially show the per-character label, and if I don’t have that it falls back to the global label. If neither exists, I just display the raw ID.

The Hot Zones Inside the Fighter Struct

There are two main “hot zones” in the fighter struct that matter most in neutral / offense / defense reading.

Hot Zone A: ~0x050–0x090 region
This block flickers like crazy during actual gameplay. It’s basically the “what are you doing this instant?” region.

Some of the bytes in here:

0x052 / 0x053: “startup tells.” These light right before an attack becomes dangerous.

0x056 / 0x057 / 0x058 / 0x059: “active/hit tells.” These spike while the move is actively hitting.

0x058 and 0x059 line up with actual strike frames really well.

If the lifetime of these bytes lines up with the “gate” I’ll describe below (0x072), I treat it as a real attack.

0x05B: tends to flip after bigger hits or state changes (hit confirm window / recovery onset).

I originally used these values to get startup/active/recovery frame counts for frame data dumps.

The engagement/stun/recovery state bytes live here too and they’re gold:

0x062 (1 byte): I call this f062.
This is basically “engagement / stun context.”
Observed values include:

160 → IDLE_BASE (fully neutral)

168 → ENGAGED (you’re “armed,” even fullscreen, evaluating collision)

32 → ACTIVE_MOVE (moving / crouching / acting)

0 → ATTACK_ACTIVE (you’re currently performing an attack)

40 → IMPACTED (defender when the exact frame of being hit)

8 → STUN_LOCK (victim in hitstun or blockstun, frozen)
The rough logic I’m using:

160 means “I’m done, neutral”

anything else is “I’m in some kind of offense/defense exchange,” including blockstun or hitstun
This byte flips on the defender before the hit actually connects (“anticipation”), and on the attacker when they commit.

0x063 (1 byte): I call this f063.
This byte is insane. It’s basically “what precise phase am I in right now?”
I’ve seen all of these:
Ground/general:
1 → NEUTRAL (fully actionable)
0 → STARTUP (you pressed a button, you’re now locked)
32 → STARTUP (same bucket as 0, early part)
6 → HIT_COMMIT (attacker ~2f before hit; locked in)
34 → CHAIN_BUFFER (you’ve already buffered the next normal, e.g. A→B)
36 → HIT_RESOLVE (pushback being applied to attacker post-hit)
4 → HITSTUN_PUSH (victim shove in hitstun/blockstun)
16 → BLOCK_PUSH (attacker being pushed back on block)
37 / 5 → RECOVERY (still in post-move cleanup)
17 → ATKR_READY (attacker has their turn back; basically “you’re plus now”)
168 → DEF_READY (defender finally got control back after hit/block)
Air/juggle/knockback:
65 → AIR_CANCEL (launcher → jump cancel window)
64 → AIR_ASCEND_ATK (air normal during rising)
192 → AIR_DESC_ATK (air normal while falling)
193 → FALLING (airborne falling state after action)
70 → AIR_PREHIT (about to connect vs grounded/air target)
68 → AIR_IMPACT (air normal connected)
196 → KB_VERTICAL (vertical launch knockback application starting)
198 → KB_VERTICAL_PEAK (fully popped up)
197 → KB_GROUNDED (grounded knockback result from an air hit)
96 / 224 / 230 → AIR_CHAIN_BUF* (buffered followups during air strings)
194 → AIR_CHAIN_END (end of the juggle chain before you start falling again at 192)
This one byte (f063) is how I detect:

did you hit?

are you in pushback?

can you chain cancel?

are you now “ready” again?

did you just land from air and are burning landing recovery?

0x064 (1 byte): f064
I’m polling this but it’s not fully decoded yet. It spikes around certain airborne states. I suspect it’s either a substate of air/landing or some “air subtype” that pairs with f063.

0x072 (byte/word region): f072
This is what I call the “master gate.”
If it’s nonzero, you’re “in a move.”
Duration of f072 = total move duration (startup+active+recovery).
Originally I used f072 to split pre/during/after windows for data logging; when 0x058/0x059 line up with f072’s active duration, I treat that as a valid strike sequence.

Hot Zone B: ~0xBB00–0xBBE0 region (still in the fighter struct)
This block turned out to be equally important, just later in memory. This is where a lot of “truth flags” live for stun, assist, landing recovery, facing, etc. These are the bytes the game is using to drive real outcomes, and sometimes the UI lies about them.

Key bytes/words from this region:

0xBB20
Grounded hitstun/blockstun flag.
This thing is extremely reliable for normal hits/blockstrings.
When you’re in grounded hitstun or blockstun (off normals), this flips.
I’m treating this as TRUE_STUN.
Caveat: I’ve seen that supers/specials don’t always reflect here the same way, so specials/supers might use a different sub-flag.

0xBDF0 / 0xBAF0
I’ve caught these behaving like stun flags per slot (P1C1, P1C2). I’m pretty sure these are either mirrors of 0xBB20 per character slot or at least per-side copies (active vs assist). This confirms the engine redundantly stores “is this guy in hitstun?” in multiple nearby places for different systems to read quickly.

0xBB00
Landing recovery / post-air landing recovery.
This flag flips when you touch the ground after doing air actions and forces you through grounded landing lag.
This solves one of the nastiest parts of advantage testing: after a jump-in or air normal, how soon can each side act? I can watch this byte to time when somebody is still burning landing recovery frames versus when they’re actually actionable.

0xBA90
Facing / orientation flag.
This flips when the character physically turns around.
It doesn’t fire for “pseudo-crossup” unless the game actually decides you’ve swapped sides. This is the byte that says “the engine now officially considers you to be facing the other way.”
I can HUD this as “L” vs “R” and prove when TvC thinks you’ve actually side-switched.

0xBA50 (and neighbors like 0xBB90 / 0xBBE0)
Assist cluster.
This area clearly tracks assist state.
I’ve seen 0xBB90/0xBBE0 reflect “assist OK” vs “assist locked,” and 0xBBE0 in particular sits at a clean 0x00 baseline when assist is totally good to go.
This is the real assist availability, not the UI portrait guess.

0xBAA0
Assist vector math.
This region looks like X/Y deltas and positional info linking the assist to the opponent:

I’ve watched it behave like “P2 distance from P1 assist, X/Y vector,” and it even updates when the assist or projectile is pursuing the opponent.

This is basically the assist’s targeting/tracking math and proximity line.

It’s nuts, because it means I can know when an assist is actually lining up to connect before it even visibly overlaps.

0xB9F0
Internal combo counter / true juggle count / “valid hitstun” counter.
This increments in ways that match how long you’ve actually been in a juggle / hit sequence.
My read is this is what the engine uses for scaling, burst/escape logic, etc.
This matters because the game’s visible combo counter can de-sync or stop displaying, but this internal number is still advancing.

0xCBA8–0xCBA9
Baroque-ready flag(s).
This is gigantic.
These bytes flip when Baroque is actually available.
I don’t have to infer from red life anymore. I can just read this and say “Baroque: READY / NOT READY.”
This is how I’m going to display Baroque status in my HUD from now on.

TL;DR:
Hot Zone A (0x050–0x090 range) tells me “what animation/phase am I in right now?”
Hot Zone B (0xBB00–0xBBE0+ range) tells me “how the engine is treating me right now” (stunned, landing recovery, facing, assist online, baroque ready, combo-in-progress count).

Movement / Velocity / Knockback Clusters

Much later in the struct there’s a big float cluster (call it the velocity/animation block) around +0xBA50..+0xBA80 and then another shove/impact cluster a little after that (BBA0 etc.). These floats spike during dashes, hitstop bursts, knockback, wallbounce, etc.

I’ve seen routines like:

0x80055DC0 / C4 / C8 writing to [r3+0xBA64/68/6C]

0x80054310 / 1C / 28 writing to [r3+0xBA70/74/78]

0x80054634 / 40 / 48 writing to [r3+0xBA7C/80]

0x800AAC7C / 84 / 8C writing to [r3+0xBA58/5C/60]

0x8004DF9C sometimes hitting [r3+0xBA50]

These write values like 1.0, 1.2, 1.3 that spike on hit or dash and then decay out. It looks like:

movement scaling

animation rate scaling

dash burst

pushback / recoil magnitude

vertical launch velocity

If I NOP some of those writers (especially in the 0x80055xxx / 0x800551C4+ neighborhood), movement either freezes, loses knockback, or stops responding to collision in the “normal” way, so this is definitely tied to active physics, not just animation fluff.

There’s also a float that spikes hard on heavy hits or blocks, ~29.0:

I’m seeing this around +0xBBA0.

On heavy standing HP that connects, +0xBBA0 jumps ~29.

On block of the same heavy, it still jumps ~29, but the BA5x/BA7x floats don’t spike quite as high (more like ~1.1 instead of ~1.3).

That tells me:

+0xBBA0 is some “impact magnitude / shove strength / collision resolution magnitude,” and it triggers even on block.

Then the actual velocity cluster splits hit vs block by dialing different values.

Long story short: it’s not “just play an animation.” Knockback and pushback are physically written into these floats every frame in a really direct way.

Rendering / Puppet Structs (Second Layer of State)

Besides the main fighter struct, I’ve caught what looks like a separate “puppet/render pose” struct at different addresses in the 0x9246DAxx / 0x9246DBxx range:

0x9246DAE0

0x9246DAD0

0x9246DB10

These flip during hitstun, and behave like “this actor is stunned for animation / camera / pose reasons.” I’m treating these as more of a render/pose mirror of the stun state.

I’ve also seen additional timers/incrementers here:

0x9246FF00

0x9246FF10

Those constantly increment. I need to pin down what they’re counting. Possibilities:

hitstop counter,

juggle/decay budget,

cinematic freeze timer.

Either way, this convinces me TvC maintains at least two live structures per fighter:
A. Gameplay struct (HP, control, knockback, stun phase, assist state, etc.).
B. Render/camera struct (pose, stun animation, camera shake info, maybe threat proximity).

The HUD currently reads A. I’ll probably start sampling B as well to mark stun visually.

UI / Training Mode / Match-Director Globals

The game’s UI and training options aren’t magic. They’re just a bunch of globals I can write to.

Training mode / pause settings live in the 0x803F56xx–0x803F5680 range. I’ve confirmed:

At 0x803F5650:

byte 0x24:

Controls training Baroque setup.

00 = nothing

01 = 10%

02 = 20%

etc.

Basically “preload my red life % for Baroque.”

byte 0x20:

Turns on the built-in attack data display (training hitbox/frame data overlay).

Game only actually draws it in training mode. Forcing it in versus doesn’t currently render, which means versus HUD path just ignores it.

At 0x803F5670:

byte 0x20:

Turns on key display (input history).

At 0x803F5680:

byte 0x10:

P1 super meter behavior.

00 normal / 01 recover / 02 infinite.

byte 0x08:

Infinite health toggle.

byte 0x24:

Free Baroque toggle (basically “just let me Baroque, don’t consume it”).

So, yeah: infinite meter, infinite health, permanent 10% red life, attack data overlay, and input display are literally just bytes you can flip in RAM. No scripts, no menu calls. The pause menu is just writing those for you.

Assist UI lies:

0x803FB7F0, byte 0x04:

If this is 0x01, the UI will tell you assist is unavailable (greys it out, etc.).

But that does NOT necessarily mean the assist is actually locked. I’ve seen cases where the game shows “not ready,” but the underlying assist state in the fighter struct (0xBBE0 etc.) says it’s fine.

0x803FB7E0, byte 0x04:

Setting this to 0x40 makes the UI think Ryu is tagging out and flickers the “tagging out” animation in the portrait.

So 0x803FB7E0/0x803FB7F0 are UI/portrait animation and “assist cooldown icon” only.

Conclusion: the assist portrait is just cosmetics. The real assist availability is in the fighter struct cluster at ~0xBA50/0xBB90/0xBBE0 (where I see a clean 00 baseline when assist is actually usable). I’m showing both in the HUD so I can prove when the game is lying.

Combo counter / hype text:
There’s a block of UI memory starting around 0x803FB940 that handles on-screen combo text:

0x803FB940

Holds the last combo count and flashes it.

If I set byte 0x20 to 0x41, it forces the combo counter to pop on-screen again.

0x803FB950

Setting byte 0x10 to 0x40 used to make the combo counter only show the number (no text), then after I poked it too much the counter stopped appearing at all. So that’s some formatting/visibility sub-control.

0x803FB9E0

Byte 0x10 at 0x40 triggers the descriptor (“Yes,” “Awesome,” “Amazing,” etc.) to flash.

0x803FBA70

Setting byte 0x12 to 0x40 makes the Baroque UI flash on screen.

0x803FBB90 / 0x803FBB80

These react to supers. Looks like the UI side of super flash / portrait highlight.

Meanwhile, in the fighter struct I’ve got 0xB9F0 which looks like the internal combo counter / “this is still a valid chain” counter. That one keeps going even if the on-screen combo number disappears. So:

0xB9F0 = actual internal combo length / juggle state.

0x803FB940 etc. = “marketing layer” for the combo display and hype text.

I can now capture both and spot when TvC decides not to show you how dead you actually are.

Pause / match flow:

0x805610F0:

Bytes 0x18–0x24 control whether you can pause.

Zeroing them basically disables pause.

0x80561100:

Byte 0x24 darkens the screen (pause dim overlay).

So pausing is just controlled by a global “match director” block, not baked into the fighter structs. You can selectively kill the pause menu or trigger the darken overlay.

Round intro / match director:

0x80560EB0: P1 intro pose state.

0x80560FB0: P2 intro pose state.

0x805C78B0 .. ~0x805FAB70:

Huge “match director / scene controller” region.

This thing updates constantly and clearly drives camera behavior, KO freeze, announcer triggers, etc.

I haven’t fully mapped it yet, but anytime something “big and cinematic” happens, this block lights up.

Collision / threat assessment:

0x80405890 / 0x804050B0 / 0x80405530:

I’m seeing constantly moving triplets of numbers that look like position vectors. These are very likely collision candidates / hitbox or hurtbox positions feeding the overlap loop.

0x80405BF0:

Similar pattern, but reacts to hitstop more directly.

0x8049B990:

Flips with animation calls. This looks like some central animation dispatcher state.

0x80476D90 / 0x80476EB0:

These respond to being hit (light vs heavy reactions). So those are probably animation channels for reel / hit reactions.

0x80478A30:

This one is wild. Byte 0x30 here reacts whenever “something is moving toward P2,” and “something” can be P1 themselves, P1’s assist, or even a projectile.

For P1’s point character, it doesn’t fully flip until P1 is actually touching P2. That feels like a throw/proximity/“in my face” detector.

There are also two bytes next to it that are constantly shuffling, which look like a target arbitration queue.

My read is: this is the defender’s internal “threat / grab eligibility / you’re in danger right now” detection.

I’m going to surface this too, because it basically tells me when the defender believes they have to respect throw/meaty.

Frame Advantage Heuristic (Current vs Next Version)

Right now (first pass), I do this:

While two characters are “interacting,” I treat them as a pair.

“Interacting” = they’re close OR either side’s f062 isn’t 160 (i.e. somebody’s in offense/defense mode).

I watch for both to return to 160 (IDLE_BASE) in f062.

I record the frame index each one hits 160.

plus_frames = victim_idle_frame - attacker_idle_frame.

If plus_frames > 0, attacker got control back first → attacker is plus.

If plus_frames < 0, defender actually recovered first → attacker is minus.

This is decent but not perfect, because “f062 == 160” is “visually neutral,” not necessarily “first actionable frame.” There are states (like RECOVERY in f063 = 5/37) where you already have some cancel options before you’re fully neutral.

Now that I’ve got the new flags, I can do better. The plan for “first actionable frame” is:

TRUE_STUN (0xBB20) has cleared (you’re not in hitstun/blockstun anymore).

Landing recovery flag 0xBB00 is cleared (you’re not still burning landing lag).

f063 has transitioned to something like ATKR_READY (17), DEF_READY (168), or straight NEUTRAL (1), not still in BLOCK_PUSH or HIT_RESOLVE or AIR_IMPACT.

If you were airborne, you’ve already gone through the forced landing frames (which I can see on 0xBB00).

Optionally check facing flip (0xBA90) if a side switch happened mid-string, just so I don’t count that orientation rewrite as “still recovering.”

That will get much closer to “who was actually plus after that interaction,” including jump-ins and blockstrings.

Block vs Hit vs Pushblock Behavior

Because I can see the internal states, I can finally separate these cleanly.

On block:

Defender runs its own attack ID for blocking. Attack ID 48 = BLOCK.

Pushblock (attack ID 51) is literally its own “move” from the defender.

The attacker’s f063 path usually looks like:
STARTUP (0 or 32)
→ HIT_COMMIT (6)
→ BLOCK_PUSH (16) (the game is shoving the attacker away)
→ ATKR_READY (17) (attacker gets turn back)

Defender’s f062 shows STUN_LOCK / 8 and IMPACTED / 40, and f063 shows HITSTUN_PUSH / 4, then eventually DEF_READY / 168.

On hit:

You see similar sequences, but with HIT_RESOLVE (36) instead of BLOCK_PUSH, and then you get all the airborne states (AIR_PREHIT 70 → AIR_IMPACT 68 → KB_VERTICAL 196 → KB_VERTICAL_PEAK 198 → AIR_DESC_ATK 192 → FALLING 193 → landing recovery BB00, etc.).

Now, with 0xBB20 (TRUE_STUN) and 0xB9F0 (internal combo counter), I can tell:

“this was a true combo hit” (HP dropped, BB20 lit, combo counter incremented)

“this was blocked” (HP didn’t drop, but BB20 lit briefly, and defender’s attack ID is 48)

“this was pushblock” (defender’s attack ID 51, attacker’s f063 shows BLOCK_PUSH then ATKR_READY)

That should make collisions.csv way more useful because now I can tag each logged interaction as HIT / BLOCK / PUSHBLOCK automatically.

Assist Behavior and Lying UI

I’ve basically confirmed assist behavior splits into two worlds:

Gameplay truth (fighter struct assist cluster):

~0xBA50 / 0xBAA0 / 0xBB90 / 0xBBE0

0xBBE0 starts clean as 0x00 when assist is ready (“assist okay flag”).

0xBAA0 gives me assist/target X/Y deltas. I’m literally watching assist tracking vectors here.

This lets me see:

Is the assist actually callable?

Is it actively homing / lining up?

Which direction it’s attacking from.

UI lie (HUD portrait / cooldown flash):

0x803FB7F0 byte 0x04:

0x01 = “assist unavailable” as far as the portrait animation is concerned.

But this can disagree with BBE0. So it’s just the icon logic.

0x803FB7E0 byte 0x04:

Forcing 0x40 makes the portrait flicker like you’re tagging out.

Conclusion: the game will happily tell you “assist is locked” in the UI when in reality the assist is totally usable. I’m reading both values in my HUD and labeling when the portrait is lying.

Threat / Proximity / Throw Window Detection

Address 0x80478A30 looks like a defender-side threat assessment block.

What I’m seeing:

There’s a byte at offset 0x30 inside that block that flips when “something is moving toward P2.”

“Something” can be: P1 point, P1 assist, or even a projectile.

For P1 point, that byte doesn’t fully set until P1 is actually physically touching P2, which smells exactly like a throw range / grab eligibility trigger.

There are two other bytes next to it that shuffle constantly, like it’s tracking “which attacker is the live threat right now.”

This is probably how the game knows “you’re in danger” vs “you’re safe,” and whether to allow or deny certain defensive options (tech windows, etc.). I’m planning to surface this in the HUD as THREAT so I can prove which blockstrings are actually airtight and which ones the game considers ‘escapable.’

Match Director / Pause / Camera / Orientation

There’s a big “match director” region starting around 0x805C78B0 and going up to ~0x805FAB70 that lights up for a ton of global events: camera stuff, KO freeze, dramatic slowdown, intros, etc.

Related globals:

0x80560EB0: P1 intro pose data.

0x80560FB0: P2 intro pose data.

0x805610F0: a pause controller block (bytes 0x18–0x24 disable pause if you zero them).

0x80561100: byte 0x24 is the pause menu dim overlay flag (darkens the screen).

Also, I’ve messed with world boundary / facing logic via code hooks like:

0x80055560 / 0x80055574 / 0x8005557C: orientation / facing logic. If I force these, characters will face the wrong way.

0x80055654 / 0x800556CC: stage boundary and camera follow. Killing these lets P1 walk offscreen, wrap around, or break the camera lock completely. I’ve literally gotten P1 to wrap from right edge to left edge with P2 still obeying normal rules.

Assist spawn logic lives around 0x80054D30 (mr r3, r5). Modifying that makes the partner spawn at weird heights, sometimes already blocking.

Knockback / launch / wallbounce:

0x800551C4–0x800551DC is the knockback impulse cluster. NOPing these kills real pushback, breaks megacrash, makes knockdowns just stand in place.

0x80054F24 (and neighbors 0x80054F28 / 0x80054F2C / 0x80054F3C / 0x80054F44 / 0x80054F48):

These are very obviously handling vertical velocity, wallbounce, ground slam, etc. If I mess with them I get cursed behavior like swapping who actually gets launched, throwing the attacker behind the victim, zero-gravity float, etc.

Rendering submit gate:

0x80054CAC:

If I NOP this, bodies become invisible but their collision/hurtboxes still exist. That’s “submit mesh for rendering or not.”

Input gating:

0x800549BC:

NOPing this kills all inputs for that actor. So that’s almost definitely the point where player input buffer feeds the state machine each frame.

Where I Am Right Now / What I Can Already Do

At this point I can:

Dynamically find each character’s fighter struct every frame (P1 active, P1 assist, P2 active, P2 assist).

Read and display:

Health / max / red life

Meter

World position (X/Y floats)

Control word at +0x70

Attack ID + human-readable move (including BLOCK and PUSHBLOCK)

f062 (engagement/stun context)

f063 (current phase: startup, hit commit, pushback, recovery, ATKR_READY, DEF_READY, air states, etc.)

f064 (unknown air/substate byte)

f072 (move active gate)

Facing / orientation flag (0xBA90) to see if the game thinks you’ve actually turned

TRUE_STUN flag (0xBB20) which is the engine’s “you are in hitstun/blockstun right now” byte for grounded normals

Landing recovery flag (0xBB00) so I know when air actions are still locking you out after you touch the ground

Internal combo counter / juggle state (0xB9F0)

Baroque-ready flag (0xCBA8–0xCBA9) so I can flat-out say “Baroque: READY” on screen without guessing from HP

Assist OK flag from the fighter struct (0xBB90/0xBBE0 cluster) versus assist UI portrait state at 0x803FB7F0 (which lies)

Assist targeting vectors (0xBAA0) to see where the assist is trying to collide

Threat proximity / throw danger (0x80478A30 block, byte 0x30)

Training mode toggles (0x803F5650 / 0x803F5680 etc.), including infinite health/meter, always-on baroque, attack data overlay, input display

Pause controller, intro pose states, and match director globals

Detect actual hits with attacker/victim assignment by watching HP drop, distance, and these stun flags instead of relying on pretty hit sparks.

Auto-label interactions as HIT / BLOCK / PUSHBLOCK and log them to collisions.csv.

Estimate frame advantage after an interaction by timing who becomes actionable first.

Old method: wait for f062 to return to 160 (IDLE_BASE).

New method (in progress): look for TRUE_STUN cleared (BB20), landing lag cleared (BB00), and f063 hitting ATKR_READY (17) / DEF_READY (168) / NEUTRAL (1).

Force HUD-style stuff (combo counter popups, “Amazing!!” hype text, baroque splash, assist portrait flicker) on demand by writing to those UI globals in the 0x803FBxxx range. I can now literally make the game scream “AMAZING!!” even when it wasn’t going to.

Flip training toggles and match flow flags (infinite meter, input display, pause dim/lockout, etc.) just by touching a few bytes instead of navigating menus.

Open Items / Next Steps

Even with everything above, there are still a few pieces I want tighter:

A. First actionable frame detection

“Who is plus?” really means “who can act first,” not “who looks neutral first.”

With TRUE_STUN (0xBB20), landing recovery (0xBB00), facing flip state (0xBA90), and f063 (especially ATKR_READY 17 and DEF_READY 168), I can now compute first actionable frame precisely, including after air normals and side switches. I just need to wire that logic into AdvantageTracker.

B. f064 (0x064)

I see it changing mostly around airborne states. It might be sub-phases of jump, techable state, air dash eligibility, etc.

Now that I have BB00 (landing recovery) and 0x80478A30 (proximity threat), I can correlate f064 with those to narrow it down.

C. Air chain / launcher state map

I’ve mapped a whole bunch of air codes in f063 (AIR_PREHIT 70, AIR_IMPACT 68, KB_VERTICAL 196, KB_VERTICAL_PEAK 198, AIR_DESC_ATK 192, FALLING 193, AIR_CHAIN_BUF*, AIR_CHAIN_END 194).

With the landing recovery flag 0xBB00 being so obvious now, I should be able to label full juggle → landing → “your turn is over / you’re minus” windows cleanly.

D. Assist logic

I’ve got assist readiness, assist targeting vector, and the fact the UI lies.

I still want to map exact meaning of the BB90 / BBE0 bytes and how they change after calling assist (cooldown vs active lockout vs “assist is mid-action, cannot be re-summoned”).

That plus the 0x803FB7F0 portrait bytes should give a perfect assist timeline.

E. Attack ID table source

I know +0x1E8/+0x1EC stores the move/block/pushblock IDs, and I’ve got 0x8049B990 / 0x80476D90 / 0x80476EB0 lighting alongside animations.

I haven’t actually trapped the write to +0x1E8 yet to see which function assigns move IDs per normal/special.

Once I get that, I’ll be able to auto-name normals (5A / 2B / j.C, etc.) per character without maintaining a manual CSV.

F. Impact writer for +0xBBA0

I know knockback magnitude (~29.0 for heavy stuff) shows up there.

The 0x800551C4–0x800551DC cluster is definitely part of the physics impulse pipeline, because NOPing it kills pushback and wallbounce.

I want to confirm the exact stfs into [r3+0xBBA0]-ish so I can screenshot “this is literally the impulse write.”

G. Camera / zoom flag

I’ve definitely seen a flag that affects camera zoom/lock and stage depth in that big 0x805C78B0..0x805FAB70 match director region, but I didn’t grab the exact byte yet. I need to reproduce and log that.

H. Timers at 0x9246FF00 / 0x9246FF10

These increment in patterns that look like internal timers (hitstop timer, juggle decay timer, etc.).

I need to correlate them against collisions.csv timestamps to guess which one is which.

I. Threat block at 0x80478A30

I’m 99% sure this is how the defender decides “they’re in grab range / immediate danger.”

I want to test throws specifically with that byte and see if it flips exactly on throw-start frames versus just “close enough.”

If so, that gives me a built-in “this string is airtight / this string is fake” detector straight from the game’s brain.

Working Mental Model

Here’s how I see the engine now:

Each fighter slot has a “fighter struct.” That struct is the truth for that character for this frame, and the core update loop (character manager) runs over it every frame. That struct includes:

Health, red life, etc.

Control word @ +0x70, constantly sanitized every frame.

Attack/State ID @ +0x1E8/+0x1EC (and yes, BLOCK and PUSHBLOCK are real “moves” with IDs).

The “Hot Zone A” block (~0x050–0x090): startup/active tells, engagement flags (f062), phase/chain state (f063), move gate (f072), etc.
f062 tells me “engaged or idle,” f063 tells me “what exact phase are you in right now (startup, hit, block pushback, recovery, air juggle, ATKR_READY, DEF_READY).”

The “Hot Zone B” block (~0xBB00–0xBBE0 and friends): ground truth aftermath.
This is where the engine records the practical consequences:

TRUE_STUN flag (0xBB20) saying “you are in grounded hitstun/blockstun right now.”

Landing recovery (0xBB00) saying “you touched ground and you’re still burning landing lag.”

Facing/orientation (0xBA90) saying “the game officially thinks you turned around.”

Assist readiness / assist OK / assist targeting vectors (0xBA50 / 0xBAA0 / 0xBB90 / 0xBBE0).

Internal combo counter / juggle state (0xB9F0).

Baroque availability (0xCBA8–0xCBA9).

Movement/velocity/knockback floats (BA5x–BA8x, BBA0, etc.) that get written every frame by routines like 0x80055DC0 and 0x800551C4 to actually apply dash bursts, launch velocity, pushback, and impact magnitudes (~29.0 spikes on big hits). These aren’t animations; they’re actual physics impulses.

On top of that, the game keeps a bunch of global director / HUD blocks:

Training mode / pause / cheats / overlays live around 0x803F5650–0x803F5680:

Infinite meter

Infinite health

Always-barogue

Attack data display

Input display

Assist portrait status is at 0x803FB7E0 / 0x803FB7F0 and is allowed to lie. The “real assist is ready” truth is back in the fighter struct (0xBBE0, etc.).

Combo counter text, “Amazing!!” hype messages, Baroque popups, and super flash HUD are all driven by 0x803FB940+ range. I can just force those to fire.

Threat assessment and proximity danger (including throw range) lives around 0x80478A30, and it tracks point, assist, and even projectiles moving at the opponent.

Collision triplets / hitbox-ish vectors are in 0x80405890 / 0x804050B0 / 0x80405530 / 0x80405BF0. These are constantly moving XYZ-like floats that look like live hurtbox/hitbox candidates going into the overlap loop.

Match director / camera / pause overlay / round intro actors are in the 0x80560EB0+, 0x805610F0+, and gigantic 0x805C78B0..0x805FAB70 region. That blob tells the fighters how to behave cinematically (KO freeze, intro pose, camera locks, stage wrap logic).

Putting it all together:

The fighter struct is where the gameplay actually lives: stun, cancel windows, recovery, assist lockout, baroque, knockback vectors, etc.

A separate set of globals controls HUD and training mode toggles (which are just bytes in RAM, no mystery).

There’s a “match director” region that handles cinematic flow, camera, pause, intro, and tells the HUD what to show.

The stock TvC UI lies in multiple places (assist ready portrait is not authoritative, combo counter can turn off even when internal combo is still counting, etc.), but the fighter struct doesn’t lie. So my HUD is now actually more honest than the game’s HUD.